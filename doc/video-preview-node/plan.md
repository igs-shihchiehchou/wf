# VideoPreviewNode 實作計劃

**功能**：影片預覽節點 - 使用影片作為參考編輯音訊的時間偏移和裁切
**目標**：實作一個完整可用的 VideoPreviewNode，支援視覺化編輯音訊時間軸
**預計工作量**：中等（約需實作 3-5 個主要組件）

---

## 階段 1：節點基礎結構（優先度：高）

### 任務 1.1：建立 VideoPreviewNode 類別
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：建立繼承自 BaseNode 的節點類別，設定基本結構

**子任務**：
- [ ] 建立 VideoPreviewNode 類別，繼承 BaseNode
- [ ] 設定節點類型、標題、圖示（🎬）
- [ ] 定義資料結構（videoFile, videoUrl, tracks）
- [ ] 實作 setupPorts() - 建立 audio 輸入端口
- [ ] 實作 getNodeCategory() - 返回 'process'
- [ ] 匯出到 window.VideoPreviewNode

**驗收標準**：
- 節點可以在畫布上建立
- 節點顯示正確的圖示和標題
- 有一個 audio 輸入端口

**依賴**：無

---

### 任務 1.2：實作節點內容區域渲染
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：根據狀態渲染不同的節點內容（等待輸入/影片上傳/已載入影片）

**子任務**：
- [ ] 實作 renderContent() 方法
- [ ] 狀態 A：無輸入 + 無影片 → 顯示「等待輸入」
- [ ] 狀態 B：無輸入 + 有影片 → 顯示影片縮圖 + 清除按鈕
- [ ] 狀態 C：有輸入 + 無影片 → 顯示上傳按鈕 + 拖放提示
- [ ] 狀態 D：有輸入 + 有影片 → 顯示影片縮圖 + 清除按鈕
- [ ] 「開啟編輯器」按鈕：根據是否有影片決定啟用/禁用
- [ ] 使用 BaseNode 的 renderPreview() 顯示處理後的音訊

**驗收標準**：
- 節點根據狀態正確顯示不同內容
- 按鈕的啟用/禁用狀態正確
- 視覺上與其他節點風格一致

**依賴**：任務 1.1

---

### 任務 1.3：實作影片檔案載入
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：支援透過按鈕選擇和拖放載入影片檔案

**子任務**：
- [ ] 實作 bindContentEvents() 方法
- [ ] 綁定「選擇影片檔案」按鈕點擊事件
- [ ] 建立檔案選擇對話框（接受 video/*）
- [ ] 實作 loadVideoFile(file) 方法
  - [ ] 檢查檔案類型（只接受 video/*）
  - [ ] 檢查檔案大小（>100MB 顯示警告）
  - [ ] 建立 Blob URL
  - [ ] 儲存到 this.data.videoFile 和 this.data.videoUrl
  - [ ] 產生影片縮圖（使用 canvas）
  - [ ] 更新節點 UI
- [ ] 綁定拖放事件（dragover, dragleave, drop）
- [ ] 實作清除按鈕（×）功能
  - [ ] 釋放 Blob URL
  - [ ] 清除 videoFile 和 videoUrl
  - [ ] 更新節點 UI

**驗收標準**：
- 可以透過按鈕選擇影片
- 可以拖放影片到節點
- 非影片檔案顯示錯誤
- 大檔案顯示警告但允許載入
- 清除按鈕正常運作
- 影片縮圖正確顯示

**依賴**：任務 1.2

---

## 階段 2：模態視窗基礎（優先度：高）

### 任務 2.1：建立模態視窗 HTML 結構
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：建立模態視窗的 DOM 結構和基本顯示/隱藏邏輯

**子任務**：
- [ ] 實作 createModalElement() 方法
  - [ ] 建立模態遮罩層（覆蓋全螢幕）
  - [ ] 建立模態視窗容器
  - [ ] 建立標題列（含關閉按鈕）
  - [ ] 建立影片播放區域（video 元素）
  - [ ] 建立播放控制列區域（占位）
  - [ ] 建立時間軸區域（占位）
  - [ ] 建立音軌列表容器（占位）
- [ ] 實作 openEditor() 方法
  - [ ] 建立模態 DOM
  - [ ] 載入影片到 video 元素
  - [ ] 顯示模態視窗
  - [ ] 鎖定背景節點圖（添加 CSS 類）
- [ ] 實作 closeEditor() 方法
  - [ ] 停止所有播放
  - [ ] 銷毀 WaveSurfer 實例
  - [ ] 移除模態 DOM
  - [ ] 解鎖節點圖
- [ ] 綁定關閉按鈕事件
- [ ] 綁定遮罩點擊關閉（可選）

**驗收標準**：
- 點擊「開啟編輯器」顯示模態視窗
- 模態視窗覆蓋全螢幕
- 影片正確載入並顯示
- 關閉按鈕正常運作
- 背景節點圖被鎖定

**依賴**：任務 1.3

---

### 任務 2.2：實作播放控制列
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：建立播放/暫停、時間顯示等基本播放控制

**子任務**：
- [ ] 實作 renderPlaybackControls() 方法
  - [ ] 播放/暫停按鈕（▶ / ⏸）
  - [ ] 當前時間顯示（MM:SS.mmm 格式）
  - [ ] 總時長顯示
- [ ] 實作 togglePlayback() 方法
  - [ ] 播放：呼叫 video.play()
  - [ ] 暫停：呼叫 video.pause()
  - [ ] 更新按鈕圖示
- [ ] 綁定 video 元素事件
  - [ ] timeupdate：更新時間顯示
  - [ ] play：更新按鈕為暫停圖示
  - [ ] pause：更新按鈕為播放圖示
  - [ ] ended：處理播放結束
- [ ] 實作時間格式化函數（支援毫秒）

**驗收標準**：
- 播放/暫停按鈕正常運作
- 時間顯示精確到毫秒
- 影片播放時時間即時更新

**依賴**：任務 2.1

---

### 任務 2.3：實作統一時間軸系統
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：建立時間刻度、播放游標等時間軸元素

**子任務**：
- [ ] 實作 renderTimeline() 方法
  - [ ] 計算時間軸長度（影片長度或最長音訊）
  - [ ] 渲染時間刻度標記（每秒或每分鐘）
  - [ ] 建立播放游標元素
- [ ] 實作 updatePlaybackCursor() 方法
  - [ ] 根據 video.currentTime 更新游標位置
  - [ ] 使用 requestAnimationFrame 循環更新
- [ ] 實作時間軸點擊跳轉
  - [ ] 監聽時間軸容器點擊事件
  - [ ] 計算點擊位置對應的時間
  - [ ] 設定 video.currentTime
- [ ] 實作游標拖動
  - [ ] 監聽游標 mousedown 事件
  - [ ] 實作 mousemove 拖動邏輯
  - [ ] 釋放時更新播放位置
- [ ] 實作時間軸自動擴展邏輯

**驗收標準**：
- 時間軸顯示清晰的刻度
- 播放游標隨播放移動
- 點擊時間軸可跳轉
- 拖動游標可調整播放位置

**依賴**：任務 2.2

---

## 階段 3：音軌編輯功能（優先度：高）

### 任務 3.1：渲染音軌列表
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：根據輸入音訊數量渲染音軌區域

**子任務**：
- [ ] 實作 renderTracks() 方法
  - [ ] 取得輸入音訊列表（inputs.audioFiles）
  - [ ] 確保 tracks 參數陣列長度一致
  - [ ] 為每個音訊建立音軌 DOM
    - [ ] 音軌標題（顯示檔案名）
    - [ ] 時間軸容器（與統一時間軸對齊）
    - [ ] 音訊區塊容器
- [ ] 實作 ensureTracksArray(count) 方法
  - [ ] 補齊或移除 tracks 參數到指定數量
  - [ ] 新增音軌使用預設參數 {offset: 0, cropStart: 0, cropEnd: null}
- [ ] 處理無音訊輸入的情況（只顯示影片）

**驗收標準**：
- 音軌數量與輸入音訊數量一致
- 每個音軌顯示正確的檔案名
- 時間軸容器正確對齊

**依賴**：任務 2.3

---

### 任務 3.2：渲染音訊波形區塊
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：使用 WaveSurfer.js 在音軌中顯示音訊波形

**子任務**：
- [ ] 實作 initTrackWaveSurfers() 方法
  - [ ] 為每個音軌建立 WaveSurfer 容器
  - [ ] 根據 tracks[i] 參數計算區塊位置和寬度
    - [ ] 位置 = offset * 像素比例
    - [ ] 寬度 = (cropEnd - cropStart) * 像素比例
  - [ ] 建立 WaveSurfer 實例
  - [ ] 載入音訊資料
  - [ ] 設定波形顏色（與專案主題一致）
- [ ] 實作像素比例計算（時間 → 像素）
- [ ] 處理裁切部分的半透明顯示
- [ ] 儲存 WaveSurfer 實例以供後續操作

**驗收標準**：
- 每個音軌正確顯示波形
- 波形位置對應 offset 參數
- 波形寬度對應音訊長度
- 視覺上清晰美觀

**依賴**：任務 3.1

---

### 任務 3.3：實作時間偏移拖動
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：允許拖動音訊區塊調整時間偏移

**子任務**：
- [ ] 實作 bindTrackDragEvents() 方法
  - [ ] 監聽音訊區塊中間區域 mousedown
  - [ ] 判斷是否在中間區域（不在邊緣）
  - [ ] 記錄拖動起始位置和初始 offset
- [ ] 實作拖動邏輯（mousemove）
  - [ ] 計算拖動距離（像素）
  - [ ] 轉換為時間偏移（像素 → 秒）
  - [ ] 更新 tracks[i].offset
  - [ ] 更新音訊區塊位置（CSS transform）
  - [ ] 顯示即時偏移提示（例如：+2.350s）
- [ ] 實作拖動結束（mouseup）
  - [ ] 移除拖動監聽
  - [ ] 隱藏偏移提示
  - [ ] 檢查時間軸是否需要擴展
- [ ] 實作游標樣式變化（↔）
- [ ] 允許負偏移（拖到時間軸起點之前）

**驗收標準**：
- 可以左右拖動音訊區塊
- 拖動時顯示即時偏移值
- 游標正確變化
- 允許負偏移
- 時間軸自動擴展

**依賴**：任務 3.2

---

### 任務 3.4：實作裁切邊界調整
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：允許從左右邊緣拖動調整音訊裁切點

**子任務**：
- [ ] 實作邊緣檢測邏輯
  - [ ] 判斷滑鼠是否在左邊緣（<10px）
  - [ ] 判斷滑鼠是否在右邊緣（最後 10px）
  - [ ] 更新游標樣式（◀ / ▶）
- [ ] 實作左邊緣裁切
  - [ ] 監聽左邊緣 mousedown
  - [ ] mousemove：向右拖動增加 cropStart
  - [ ] 更新波形區塊位置和寬度
  - [ ] 確保 cropStart < cropEnd - 0.1
  - [ ] 顯示裁切後長度提示
- [ ] 實作右邊緣裁切
  - [ ] 監聽右邊緣 mousedown
  - [ ] mousemove：向左拖動減少 cropEnd
  - [ ] 更新波形區塊寬度
  - [ ] 確保 cropEnd > cropStart + 0.1
  - [ ] 顯示裁切後長度提示
- [ ] 實作最小長度限制（0.1 秒）
- [ ] 更新裁切部分的半透明顯示

**驗收標準**：
- 左邊緣可以向右拖動裁切開頭
- 右邊緣可以向左拖動裁切結尾
- 拖動時右側/左側位置保持不變
- 最小長度限制生效
- 波形正確更新

**依賴**：任務 3.3

---

## 階段 4：播放同步（優先度：高）

### 任務 4.1：實作音訊播放引擎
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：使用 Web Audio API 同步播放多個音訊

**子任務**：
- [ ] 實作 setupAudioContext() 方法
  - [ ] 取得或建立 AudioContext
  - [ ] 為每個音軌建立 GainNode（音量控制，未來擴展）
- [ ] 實作 startAudioPlayback(startTime) 方法
  - [ ] 停止所有正在播放的 AudioBufferSourceNode
  - [ ] 為每個音軌建立新的 AudioBufferSourceNode
  - [ ] 根據 tracks[i] 參數計算播放參數
    - [ ] 計算音訊應該播放的時間點
    - [ ] 計算裁切範圍內的 offset 和 duration
  - [ ] 使用 source.start(when, offset, duration) 精確控制
  - [ ] 連接到 AudioContext.destination
  - [ ] 儲存 source 實例以供停止
- [ ] 實作 stopAudioPlayback() 方法
  - [ ] 停止所有 AudioBufferSourceNode
  - [ ] 清理實例
- [ ] 實作播放計算邏輯
  - [ ] audioPlayTime = currentTime - offset + cropStart
  - [ ] 判斷是否應該播放（在裁切範圍內）

**驗收標準**：
- 多個音訊可以同時播放
- 音訊根據 offset 參數正確延遲
- 裁切參數正確應用
- 播放時機精確

**依賴**：任務 2.2

---

### 任務 4.2：整合影片和音訊同步播放
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：統一控制影片和音訊的播放

**子任務**：
- [ ] 修改 togglePlayback() 方法
  - [ ] 播放：同時啟動影片和音訊
  - [ ] 暫停：同時停止影片和音訊
- [ ] 實作播放循環更新
  - [ ] 使用 requestAnimationFrame
  - [ ] 更新播放游標位置
  - [ ] 更新時間顯示
  - [ ] 檢查音訊是否需要啟動/停止
- [ ] 實作跳轉時的重新同步
  - [ ] 停止當前播放
  - [ ] 設定新的播放位置
  - [ ] 如果正在播放，重新啟動
- [ ] 處理影片結束後繼續播放音訊
  - [ ] 監聽 video ended 事件
  - [ ] 影片停留在最後一幀
  - [ ] 音訊繼續播放直到全部結束
- [ ] 處理音訊全部播放完畢

**驗收標準**：
- 影片和音訊完美同步
- 暫停和播放立即響應
- 跳轉後正確重新同步
- 影片結束後音訊繼續播放

**依賴**：任務 4.1, 任務 2.3

---

## 階段 5：資料處理與輸出（優先度：中）

### 任務 5.1：實作 process() 方法
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：根據編輯參數處理音訊並輸出

**子任務**：
- [ ] 實作 process(inputs) 方法
  - [ ] 接收輸入音訊列表（inputs.audioFiles）
  - [ ] 確保 tracks 參數陣列長度一致
  - [ ] 為每個音訊應用處理
    - [ ] 步驟 1：裁切（cropStart, cropEnd）
    - [ ] 步驟 2：應用時間偏移（offset）
  - [ ] 返回處理後的音訊列表
- [ ] 實作 applyTimeOffset(buffer, offset) 方法
  - [ ] 正偏移：在開頭添加靜音
    - [ ] 建立新的 AudioBuffer
    - [ ] 複製原音訊到偏移位置
  - [ ] 負偏移：裁切開頭部分
    - [ ] 使用 audioProcessor.cropAudio()
  - [ ] 返回處理後的 buffer
- [ ] 處理無輸入的情況
- [ ] 輸出格式：{audio, audioFiles, filenames}

**驗收標準**：
- 正偏移正確添加靜音
- 負偏移正確裁切
- 裁切範圍正確應用
- 輸出音訊可以播放和下載

**依賴**：任務 3.4

---

### 任務 5.2：整合 BaseNode 預覽系統
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：使用 BaseNode 的多檔案預覽系統顯示處理結果

**子任務**：
- [ ] 確保 process() 輸出格式正確
  - [ ] audioFiles 陣列
  - [ ] filenames 陣列
- [ ] 測試預覽區域顯示
  - [ ] 處理後的音訊出現在節點底部
  - [ ] 每個音訊有獨立的波形和播放按鈕
  - [ ] 每個音訊有獨立的輸出端口
- [ ] 測試輸出連接
  - [ ] 可以連接到其他節點
  - [ ] 資料正確傳遞

**驗收標準**：
- 預覽區域正確顯示處理結果
- 每個音訊可以預覽播放
- 輸出端口可以連接到其他節點

**依賴**：任務 5.1

---

## 階段 6：樣式與 UI 優化（優先度：中）

### 任務 6.1：建立 CSS 樣式
**檔案**：`css/video-preview.css`
**描述**：為模態視窗和節點建立樣式

**子任務**：
- [ ] 建立 video-preview.css 檔案
- [ ] 模態遮罩樣式
  - [ ] 全螢幕覆蓋
  - [ ] 半透明黑色背景
- [ ] 模態視窗樣式
  - [ ] 居中顯示
  - [ ] 適當的寬度和高度
  - [ ] 深色背景（符合專案主題）
  - [ ] 圓角和陰影
- [ ] 標題列樣式
  - [ ] 標題文字
  - [ ] 關閉按鈕
- [ ] 影片播放區域樣式
  - [ ] 16:9 或自適應比例
  - [ ] 背景色
- [ ] 播放控制列樣式
  - [ ] 按鈕樣式（播放/暫停）
  - [ ] 時間顯示字體
- [ ] 時間軸樣式
  - [ ] 刻度線和標籤
  - [ ] 播放游標（垂直線）
  - [ ] 互動反饋（hover, active）
- [ ] 音軌區域樣式
  - [ ] 音軌標題
  - [ ] 時間軸容器背景
  - [ ] 音訊區塊樣式
  - [ ] 波形容器
  - [ ] 拖動時的視覺反饋
  - [ ] 裁切邊緣控制柄
- [ ] 節點內容樣式
  - [ ] 影片縮圖
  - [ ] 按鈕樣式
  - [ ] 拖放提示
  - [ ] 禁用狀態
- [ ] 響應式設計（可選）

**驗收標準**：
- 視覺上與專案主題一致
- UI 元素清晰易用
- 互動反饋明顯
- 符合設計稿要求

**依賴**：任務 4.2

---

### 任務 6.2：引入 CSS 到 index.html
**檔案**：`index.html`
**描述**：在 HTML 中引入新的 CSS 檔案

**子任務**：
- [ ] 在 `<head>` 中添加 CSS 引用
  ```html
  <link rel="stylesheet" href="css/video-preview.css">
  ```
- [ ] 確保載入順序正確（在其他樣式之後）

**驗收標準**：
- CSS 正確載入
- 樣式生效

**依賴**：任務 6.1

---

## 階段 7：系統整合（優先度：高）

### 任務 7.1：註冊節點到系統
**檔案**：`index.html`, `js/graphEngine.js`, `js/nodePanel.js`
**描述**：將 VideoPreviewNode 註冊到節點系統

**子任務**：
- [ ] 在 index.html 引入節點腳本
  ```html
  <script src="js/nodes/VideoPreviewNode.js"></script>
  ```
- [ ] 在 graphEngine.js 的 nodeTypes 中註冊
  ```javascript
  this.nodeTypes = {
    // ...existing
    'video-preview': VideoPreviewNode
  };
  ```
- [ ] 在 nodePanel.js 中添加到節點列表
  ```javascript
  {
    type: 'video-preview',
    label: '影片預覽',
    icon: '🎬',
    description: '使用影片作為參考編輯音訊時間軸'
  }
  ```
- [ ] 在 graphEngine.js 的 context menu 中添加

**驗收標準**：
- 節點面板顯示影片預覽節點
- 可以拖拉建立節點
- 右鍵選單包含影片預覽選項

**依賴**：任務 5.2

---

### 任務 7.2：實作序列化與還原
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：支援儲存和載入工作流

**子任務**：
- [ ] 實作 toJSON() 方法
  - [ ] 呼叫 super.toJSON()
  - [ ] 添加 tracks 參數陣列
  - [ ] 不序列化 videoFile 和 videoUrl
- [ ] 實作 static fromJSON(json) 方法
  - [ ] 建立節點實例
  - [ ] 還原 tracks 參數
  - [ ] 還原位置和其他屬性
- [ ] 測試儲存和載入
  - [ ] 儲存工作流
  - [ ] 關閉工具
  - [ ] 重新開啟並載入
  - [ ] 驗證參數正確還原

**驗收標準**：
- 儲存工作流包含編輯參數
- 載入後參數正確還原
- 提示使用者重新載入影片

**依賴**：任務 7.1

---

## 階段 8：錯誤處理與優化（優先度：中）

### 任務 8.1：錯誤處理
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：處理各種錯誤情況

**子任務**：
- [ ] 影片載入錯誤處理
  - [ ] try-catch 包裝
  - [ ] 顯示錯誤 toast
  - [ ] 清除資料
- [ ] 檔案格式驗證
  - [ ] 檢查 MIME type
  - [ ] 顯示友善錯誤訊息
- [ ] 大檔案警告
  - [ ] 檢查檔案大小 >100MB
  - [ ] 顯示警告但允許繼續
- [ ] 大量音軌警告
  - [ ] 檢查音軌數量 >10
  - [ ] 顯示效能警告
- [ ] 邊界情況處理
  - [ ] 無輸入音訊
  - [ ] 空的 AudioBuffer
  - [ ] 無效的 tracks 參數

**驗收標準**：
- 錯誤不會導致崩潰
- 顯示友善的錯誤訊息
- 警告不阻止操作

**依賴**：任務 7.2

---

### 任務 8.2：記憶體管理
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：確保正確釋放資源

**子任務**：
- [ ] 關閉編輯器時釋放資源
  - [ ] 銷毀所有 WaveSurfer 實例
  - [ ] 停止所有 AudioBufferSourceNode
  - [ ] 移除事件監聽
  - [ ] 移除 DOM 元素
- [ ] 切換影片時釋放舊影片
  - [ ] 釋放舊的 Blob URL
  - [ ] 清理 video 元素
- [ ] 節點刪除時清理
  - [ ] 釋放影片資源
  - [ ] 清理所有監聽

**驗收標準**：
- 關閉編輯器後記憶體釋放
- 無記憶體洩漏
- Blob URL 正確釋放

**依賴**：任務 8.1

---

### 任務 8.3：效能優化
**檔案**：`js/nodes/VideoPreviewNode.js`
**描述**：優化播放和渲染效能

**子任務**：
- [ ] 使用 requestAnimationFrame 優化播放循環
- [ ] 波形渲染優化
  - [ ] 只在需要時重新渲染
  - [ ] 避免頻繁建立/銷毀 WaveSurfer
- [ ] 拖動時的性能優化
  - [ ] 使用 CSS transform 而非改變 position
  - [ ] 節流更新（throttle）
- [ ] 大量音軌時的優化
  - [ ] 虛擬滾動（如果超過 20 個音軌，可選）

**驗收標準**：
- 播放流暢，無卡頓
- 拖動響應快速
- 支援 10 個以上音軌無明顯延遲

**依賴**：任務 8.2

---

## 階段 9：測試與文檔（優先度：低）

### 任務 9.1：手動測試
**描述**：執行完整的功能測試

**測試場景**：
- [ ] 基本流程
  - [ ] 建立節點 → 載入影片 → 連接音訊 → 開啟編輯器
  - [ ] 調整時間偏移 → 調整裁切 → 關閉編輯器
  - [ ] 執行節點 → 驗證輸出 → 連接到其他節點
- [ ] 邊界情況
  - [ ] 無影片僅音訊
  - [ ] 無音訊僅影片
  - [ ] 大量音軌（15 個）
  - [ ] 超長影片（>10 分鐘）
  - [ ] 負偏移
  - [ ] 音訊超出影片長度
- [ ] 錯誤情況
  - [ ] 非影片檔案
  - [ ] 損壞的影片
  - [ ] 大檔案
- [ ] 序列化
  - [ ] 儲存和載入工作流
  - [ ] 參數正確還原
- [ ] 整合測試
  - [ ] 與其他節點的連接
  - [ ] 複雜工作流

**驗收標準**：
- 所有 BDD 場景通過
- 無重大 bug
- 使用體驗流暢

**依賴**：任務 8.3

---

### 任務 9.2：更新 CLAUDE.md
**檔案**：`CLAUDE.md`
**描述**：更新專案文檔

**子任務**：
- [ ] 在節點類型表格中添加 video-preview
  - [ ] 類型：video-preview
  - [ ] 圖示：🎬
  - [ ] 描述：使用影片作為參考編輯音訊時間軸
- [ ] 更新模組結構（如果需要）
- [ ] 添加使用說明（可選）

**驗收標準**：
- 文檔準確反映新功能

**依賴**：任務 9.1

---

## 實作順序建議

建議按照以下順序實作，可以盡早看到可用的功能：

1. **第一輪（基礎可用）**：
   - 階段 1（任務 1.1 → 1.3）：建立節點基礎，可以載入影片
   - 階段 2（任務 2.1 → 2.2）：可以開啟模態視窗並播放影片
   - 階段 7（任務 7.1）：註冊到系統，可以在節點面板使用

2. **第二輪（核心功能）**：
   - 階段 2（任務 2.3）：時間軸系統
   - 階段 3（任務 3.1 → 3.4）：音軌編輯功能
   - 階段 4（任務 4.1 → 4.2）：播放同步

3. **第三輪（完整功能）**：
   - 階段 5（任務 5.1 → 5.2）：資料處理與輸出
   - 階段 6（任務 6.1 → 6.2）：樣式優化
   - 階段 7（任務 7.2）：序列化

4. **第四輪（優化）**：
   - 階段 8（任務 8.1 → 8.3）：錯誤處理與優化
   - 階段 9（任務 9.1 → 9.2）：測試與文檔

---

## 風險與注意事項

1. **瀏覽器相容性**：
   - Web Audio API 在不同瀏覽器可能有差異
   - 影片編解碼器支援度不同
   - 建議主要支援 Chrome/Edge

2. **效能考量**：
   - 大量音軌可能影響效能
   - 長影片記憶體佔用較大
   - 需要適當的警告和限制

3. **同步精確度**：
   - Web Audio API 和 Video 元素的同步可能有微小誤差
   - 需要測試和微調

4. **使用者體驗**：
   - 拖動交互需要足夠的視覺反饋
   - 時間軸需要清晰易讀
   - 操作需要直觀

---

## 總結

這個實作計劃將 VideoPreviewNode 功能拆解成 **36 個子任務**，分為 **9 個階段**。按照建議的順序實作，可以在每個階段都看到可用的進展，便於測試和調整。

預計完整實作需要：
- 核心功能（階段 1-5）：約 60-70% 工作量
- UI 優化（階段 6）：約 15% 工作量
- 整合與優化（階段 7-8）：約 15% 工作量
- 測試（階段 9）：約 10% 工作量（與開發並行）

建議使用 subagent-driven-development 或類似的開發流程，每次完成一個小任務並測試，確保品質。
